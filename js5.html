<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="that js dude" content="">    
    <title>JS: interview Questions -5</title>

    <link rel="shortcut icon" href="images/favicon.jpg">    
    <link rel="stylesheet" href="css/bootstrap.min.css" >
    <link rel="stylesheet" href="css/zenburn.css">
    <!-- Custom styles for this template -->
    <style>
      /* Move down content because we have a fixed navbar that is 50px tall */
      body {        
        padding-bottom: 20px;
      }
      .purpleBold{
        color:purple;        
        font-weight: bold;
      }
      .gray{
        color: gray;
      }
      .blueish{
        color: rgba(151, 182, 209, 0.98);
      }
      .singInStuff{
        margin-top: 9px;
      }
      #uName{
        margin-top: -7px;
      }
      .skipListItem{
        list-style-type: none;
      }
      .skipListItem a{
        color: inherit;
      }
      a:visited
      { 
        color: rgba(218, 209, 149, 0.98);
      }
      .padding10Px{
        padding: 10px;
      }
      /*style for demo*/
      
    </style>

    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="docs-assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
 
  <body>

    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron">
      <div class="container">
        <h1>JS: Interview Questions</h1>        
        <h4>Search and sort related interview questions for intermediate JavaScript developers</h4>
        <h2>part-5: intermediate</h2>
        <p>June 29, 2014</p>
<!--         <div id="fb-root"></div><div class="fb-like" data-href="http://www.thatjsdude.com/interview/dom.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></div><div class="g-plusone"></div> 
 -->      </div> 
    </div>
    <div class="container container-fluid">
      <!-- Example row of columns -->

      <div class="row center">        
        <!-- <iframe width="853" height="480" src="//www.youtube.com/embed/Rx_JFOSxgpY" frameborder="0" allowfullscreen></iframe> -->
      </div>
           
      <!-- <p class="gray">if you are little more comfortable or claim to be comfortable with javascript, these questions would not be enough for you. more coming</p>
      <p class="gray"> <span class="purpleBold">More Questions</span> <a href="css.html">css interview questions</a>, <a href="html.html">html interview questions</a> </p> -->
    <div id="questionList">
      <h2>todo list</h2>
      <ol>
        <li>add questions</li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ol>
    </div>
    
      <div id="binarySearch">
        <h2>binary search</h2>
        <p><strong>Question:</strong> How to implement binary search algorithm?</p>
        <p><strong>Answer:</strong> Here is the iterative way of implementing binary search in an array. Just think about what is the condition in the while loop. Why it is like that. You can figure out rest of it</p>
        <pre><code>
function binarySearchIterative(arr, val){
   var start = 0,
       end = arr.length-1, 
       mid, 
       midVal;
    
   while(end >= start){
     mid = Math.floor((start+end)/2);

     midVal = arr[mid];
          
     if(midVal==val)
         return mid;
     
     if(val&lt;midVal)
         end = mid - 1;
     if(val&gt;midVal)
         start = mid + 1;
          
  } 
  return -1;
}

//try it now
binarySearchIterative([1,2,3,4,5], 1); //0
binarySearchIterative([1,2,3,4,5], 5); //4
binarySearchIterative([1,2,3,4,5], 55); //-1
        </code></pre>
        <pstrong  Performance</p>
        <p>Recusrive algo</p>
        <pre><code>
function binarySearchRecursive(arr, val, startIdx, endIdx){
   var mid = Math.floor((startIdx + endIdx)/2), 
       midVal = arr[mid];
   
   if(midVal == val)
      return mid;
   if (endIdx &lt; startIdx)
      return -1;

   if (val&lt;midVal)
      return binarySearchRecursive(arr, val, startIdx, mid -1);
   else if (val &gt; midVal)
      return binarySearchRecursive(arr, val, mid + 1, endIdx);

}

//try it now
binarySearchRecursive([1,2,3,4,5], 1, 0, 4); //0
binarySearchRecursive([1,2,3,4,5], 5, 0, 4); //4
binarySearchRecursive([1,2,3,4,5], 2, 0, 4); //1
binarySearchRecursive([1,2,3,4,5], 22, 0, 4); //-1
        </code></pre>
        <p>ref: <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a></p>
      </div>  
      <div id="bubbleSort">
        <h2>bubble sort</h2>
        <p><strong>how does it works:</strong> In the code block below, you see two loops. one is inside another. the inner one starts with 1 and checks whether whether the previous value is greater than the current value. if previous one is bigger it swaps it. hence the smaller one goes to left and bigger one right. now the right one is compared again with the next. hence the bigger the biggest one taken to the right.</p>
        <p>look at the upper limit of the loop value is "i". hence it will run full length first time. second time value of i gets one less of the full length.</p>
        <p>the looping again starts from the the second element and compare the second one with the first item. if the first one is bigger than the second one, it is swapped. and goes upto the second to the last. Hence the second highest number goes to the second to the last position</p>
        <p>same thing is going on....</p>
        <pre><code>
function bubbleSort(arr){
   var len = arr.length;
   for (var i = len-1; i>=0; i--){
     for(var j = 1; j<=i; j++){
       if(arr[j-1]>arr[j]){
           var temp = arr[j-1];
           arr[j-1] = arr[j];
           arr[j] = temp;
        }
     }
   }
   return arr;
}
bubbleSort([7,5,2,4,3,9]); //[2, 3, 4, 5, 7, 9]
bubbleSort([9,7,5,4,3,1]); //[1, 3, 4, 5, 7, 9]
bubbleSort([1,2,3,4,5,6]); //[1, 2, 3, 4, 5, 6]
        </code></pre>
        <p><strong>complexity:</strong></p>
      </div>   
      <div id="selectionSort">
        <h2>Selection Sort</h2>
        <p><strong>how does it works:</strong> It selects the lowest element in the array for a particular position. Here, for the first position of the array it goes through the whole array and find the index of the lowest element. After getting the index of the lowest element. it swaps the lowest element with the element in the first position. Hence the lowest in the array comes to the first position.</p>
        <p>now looks for the second lowest for the second position element. by comparing rest of the elements and keep going</p>
        <pre><code>
function selectionSort(arr){
  var minIdx, temp;
  for(var i =0, len = arr.length; i&lt;len; i++){
    minIdx = i;
    for(var  j = i+1; j&lt;len; j++){
       if(arr[j]&lt;arr[minIdx]){
          minIdx = j;
       }
    }
    temp = arr[i];
    arr[i] = arr[minIdx];
    arr[minIdx] = temp;
  }
  return arr;
}
        </code></pre>
        <p><strong>complexity:</strong></p>
      </div>
      <div id="insertionSort">
        <h2>Insertion sort</h2>
        <p><strong>how does it works</strong>: It starts with the second element. pick the second element to be inserted and put it in a temp variable toInsert. if the first one is bigger than the item to be inserted, we move the first.</p>
        <p>Now first and second item is sorted.</p>
        <p>Then, pick the third element and check whether the second element is bigger than the third (toInsert). if smaller, move the second to the third position. Now, check with first element whether first is smaller than toInsert, move first one to the second position. Now insert toInsert in the first position.</p>
        <p>now first three elements are sorted.</p>
        <pre><code>
function insertionSort(arr){
  for(var i =1, len = arr.length; i&lt;len; i++){
    var toInsert = arr[i];
    var j = i;
    while(j>0 && arr[j-1]>toInsert){
      arr[j] = arr[j-1];
      j--;   
   }
   arr[j] = toInsert;
  }
  return arr;
}
        </code></pre>
        <p><strong>complexity:</strong> the worst case O(n2) and best case O(n)</p>
      </div>
      <div id="mergeSort">
        <h2>Merge Sort</h2>
        <p>its a divide and conquer type algorithm. </p>
        <p>just break down your array into small and small pieces and until you have one items in each pieces. then merge together by comparing them. If you still have hard time to figure out what i am talking about, look at <a href="http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif">wiki merge sort gif</a></p>
        <pre><code>
function mergeSort(arr){
   var len = arr.length;
   if(len &lt;2)
      return arr;
   var mid = Math.floor(len/2),
       left = arr.slice(0,mid),
       right =arr.slice(mid);
   //send left and right to the mergeSort to broke it down into pieces
   //then merge those
   return merge(mergeSort(left),mergeSort(right));
}
        </code></pre>
        <pre><code>
function merge(left, right){
  var result = [],
      lLen = left.length,
      rLen = right.length,
      l = 0,
      r = 0;
  while(l&lt; lLen && r&lt;rLen){
     if(left[l]&lt;right[r]){
       result.push(left[l++]);
     }
     else{
       result.push(right[r++]);
    }
  }  
  //remaining part needs to be addred to the result
  return result.concat(left.slice(l)).concat(right.slice(r));
}
        </code></pre>
        <p>ref: <a href="http://www.nczonline.net/blog/2012/10/02/computer-science-and-javascript-merge-sort/">merge sort</a></p>
      </div>
      <div id="quickSort">
        <h2>Quick sort</h2>
        <p><strong>how does it works:</strong></p>
        <p>try to understand this one. in depth</p>
        <pre><code>
function swap(arr, i, j){
   var temp = arr[i];
   arr[i] = arr[j];
   arr[j] = temp;
}
        </code></pre>
        <pre><code>
function partition(arr, pivot, left, right){
   var storeIndex = left,
       pivotValue = arr[pivot];

   swap(arr, pivot, right);
   
   for(var i = left; i&lt;right;i++){
    if(arr[i]&lt;pivotValue){
      swap(arr, i, storeIndex);
      storeIndex++;
    }
  }
  swap(arr, right, storeIndex);
  return storeIndex;
}
        </code></pre>
        <pre><code>
function quickSort(arr, left, right){
   var len = arr.length, 
   pivot,
   newPivot;


  if(left &lt; right){
    pivot = left + Math.ceil((right - left)*0.5);
    newPivot = partition(arr, pivot, left, right);
    
   //sort left and right
   quickSort(arr, left, newPivot-1);
   quickSort(arr, newPivot +1, right);
  }
  return arr;
}
        </code></pre>
        <p>ref: <a href="https://gist.github.com/paullewis/1981455">quick sort</a></p>
      </div>
      <div id="heapSort">
        <h2>Heap sort</h2>        
        <p><strong>how does it works: </strong> first step is to build an heap. That is done in the heapify function. Hepaify put the largest element at the root.</p>
        <h2 class="bg-danger">Don't understand a single bit of it</h2>
        <pre><code>
function heapSort(arr){
  var len = arr.length,
      end = len-1;

  heapify(arr, len);
  
  while(end > 0){
   swap(arr, end--, 0);
   siftDown(arr, 0, end);
  }
  return arr;
}
        </code></pre>
        <pre><code>
function heapify(arr, len){
   // break the array into root + two sides, to create tree (heap)
   var mid = Math.floor((len-2)/2);
   while(mid >=0){
    siftDown(arr, mid--, len-1);    
  }
}
        </code></pre>
        <pre><code>
function siftDown(arr, start, end){
   var root = start,
       child = root*2 + 1,
       toSwap = root;
   while(child <= end){
      if(arr[toSwap]&lt;arr[child]){
        swap(arr, toSwap, child);
      }
      if(child+1<=end && arr[toSwap]&lt;arr[child+1]){
        swap(arr, toSwap, child+1)
      }
      if(toSwap != root){
         swap(arr, root, toSwap);
         root = toSwap;
      }
      else{
         return; 
      }
      toSwap = root;
      child = root*2+1
  }
}
        </code></pre>
        <pre><code>
function swap(arr, i, j){
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
        </code></pre>
        <p><strong>Question:</strong> Between merge and heap sort, which one you will choose?</p>
        <p><strong>compare with other:</strong><a href="http://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts">compare heap sort with others</a></p>        
      </div>
      <div id="bucketSort">
        <h2>Bucket Sort</h2>
        <p>bucket sort or bin sort. you partition the whole array into small buckets. put numbers in the related bucket and then sort each bucket by another algorithm or using bucket sort.</p>
      </div>
      <div id="shellSort">
        <h2>Shell Sort</h2>
        <p><strong>how does it works: </strong> it takes a gap. for example gap of five. in that case it will take all the elements at 1, 6, 11, 16... and will sort them among themselves. Hence this gapped array will be sorted. secondly it will take 2, 7, 12, 17th positioned element and will sort among themselves</p>
        <p>second time. it will take all in three positioned. like 1, 4, 7, 10, 13, 16, 19 and will sort among themselves. after this all these will be sorted. and then goes to 2, 5, 8, 11, 14, 17, 20</p>
        <p>Then it will do 1 gap sorting... </p>
        <p>shell sort is rarely used in application as it performs more operations and have higher cache miss ratio than  quick sort. </p>
        <p>ref: <a href="http://en.wikipedia.org/wiki/Shell_sort">wiki: shell sort</a></p>
      </div>
      <div id="pigenholeSort">
        <h2>Pigeonhole Sort</h2>
        <p>also known as count sort (not counting sort). you have an array. and each element has a key value pair. you iterate over the original array and put each element based on the key to its small array (pigeon hole). and then iterate over the pigeonhole array in order.  </p>
        <p><strong>Counting sort: </strong> counting sort works same way, but it returns number of elements for each key other than the original elements. very thoughtful name, indeed.</p>
        <p>ref: <a href="http://en.wikipedia.org/wiki/Pigeonhole_sort">wiki pigeonhole sort</a></p>
      </div>
      <div id="binaryTreeSort">
        <h2>Binary Tree sort</h2>
      </div>
      <div id="radixSort">
        <h2>Radix Sort</h2>
        <p>its a non comparative integer sorting algorithm. it compares the integer based on the position of the number (significance). </p>
        <p>there are two radix sort. LSD (<a href="http://en.wikipedia.org/wiki/Radix_sort#An_example">least significant digit</a>) radix sort and MSD (<a href="http://en.wikipedia.org/wiki/Radix_sort#Most_significant_digit_radix_sorts">most significant digit</a>) radix sort</p>
      </div>
      <div id="cocktailSort">
        <h2>cocktail sort</h2>
        <p>also known as bidirectional bubble sort, cocktail shaker sort, shaker sort, ripple sort, shuffle sort, shuttle sort.</p>
        <p>difference with bubble sort is that this sort in both direction each pass. Its difficult to implement.</p>
      </div>
      <div id="otherSort">
        <h2>Other sorting algorithms</h2>
        <p><strong>patience sorting:</strong> sorting based on solitaire card game. you draw card either put in a new pile or existing pile. when you are putting card on a pile, a higher value card will go on top </p>
        <p><strong>comb sort: </strong> it is an improvement on bubble sort. the inner loop of bubble sort is modified so that gap between swapped elements goes down for each iteration of the outer loop by using a shrink factor. <a href="http://en.wikipedia.org/wiki/Comb_sort">wiki comb sort</a> the usual shrink factor is 1.3 and the gap (>=1) is calculated by <code>Math.floor(lenght/1.3)</code> </p>
        <p><strong>Spaghetti sort:</strong> it takes linear time but need parallel processor to sort. <a href="http://en.wikipedia.org/wiki/Spaghetti_sort">read it to understand</a></p>
        <p><strong>Intro sort:</strong>combines both quick sort and heap sort. so that worst and average becomes O(nlongn). it starts with quick sort and switch to heap sort if recursion depth increases based on the number of elements to be sorted.</p>
        <p><strong>Timsort: </strong> this is a hybrid of merge and insertion sort. try to find subset of data that is already sorted. and use that data to sort rest efficiently. and then merged by merge sort. this algorithm is primarily used in python. This actually invented by Tim peters to use in python.</p>
        <p><strong>Block sort: </strong>runs at least two merge operation with one insertion sort. <a href="http://en.wikipedia.org/wiki/Block_sort">wiki: block sort</a></p>
        <p><strong>library sort:</strong> it is an insertion sort with gaps in the array to improve insertion. <a href="http://en.wikipedia.org/wiki/Library_sort">wiki: library sort</a></p>
        <p><strong>Tournament sort: </strong> Its a selection sort with a priority queue to find the next element to sort. <a href="http://en.wikipedia.org/wiki/Tournament_sort">wiki: tournament sort</a></p>
        <p><strong>others: </strong><a href="http://en.wikipedia.org/wiki/Gnome_sort">Gnome sort</a>, <a href="http://en.wikipedia.org/wiki/UnShuffle_Sort">unshuffle sort</a>, <a href="http://en.wikipedia.org/wiki/Strand_sort">Strand sort</a>, <a href="http://en.wikipedia.org/wiki/Smoothsort">smooth sort</a></p>
      </div>
    <div>
      <h2>references</h2>
      <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </div>
    <div>
      <h2>Need more:</h2>        
      <p>JavaScript part -1: <a href="js1.html">JS basic algorithm</a></p>
      <p>CSS: <a href="css.html">css related questions</a></p>
      <p>HTML: <a href="html.html">html related questions</a></p>
      <p><strong>Full list of interview questions are </strong><a href="https://github.com/khan4019/front-end-Interview-Questions">https://github.com/khan4019/front-end-Interview-Questions</a></p>
      <p>A lot of data structure, tree, graphs related interview questions are on the pipe line. Stay tuned</p>
    </div> 
    <div>
    <h2>References</h2>
    <ul>
      <li><a href="http://bigocheatsheet.com/">big o cheat sheet</a></li>      
      <li><a href="http://www.sorting-algorithms.com/">sort algorith animation</a></li>
      <li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html">some sorting algorithm</a></li>      
    </ul>
  </div>
    <div>
      <h3 class="purpleBold">Express anger!</h3>        
      <!-- <p class="gray">Feel free to express your anger (sorry folks, you have to use g+.). Also point out my mistakes ( technical, wrong answer, spelling, grammar, sentence..., whatever), let your dude learn and grow.</p>
      <script src="https://apis.google.com/js/plusone.js"></script>
      <div class="g-comments"
          data-href="http://www.thatjsdude.com/interview/dom.html"
          data-width="642"
          data-first_party_property="BLOGGER"
          data-view_type="FILTERED_POSTMOD">
      </div>         -->
    </div>
      <hr>

      <footer>
        <p>&copy;thatJSDude 2014</p>
      </footer>
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-2.0.3.min.js"></script>    
    <script src="js/bootstrap.min.js"></script>
    <script src="js/highlight.pack.js"></script>    
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="js/toggleExample.js"></script>
    <script type="text/javascript">
      // //social plugins
      // //g+
      // (function() {
      //   var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
      //   po.src = 'https://apis.google.com/js/platform.js';
      //   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      // })();
      // //fb
      // (function(d, s, id) {
      //   var js, fjs = d.getElementsByTagName(s)[0];
      //   if (d.getElementById(id)) return;
      //   js = d.createElement(s); js.id = id;
      //   js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
      //   fjs.parentNode.insertBefore(js, fjs);
      // }(document, 'script', 'facebook-jssdk'));
    </script>
    <script type="text/javascript">        
        document.getElementById('listToDestroy').addEventListener('click', function (e) {
          var elm = e.target.parentNode;
          elm.parentNode.removeChild(elm);
          e.preventDefault();
        }); 

        document.getElementById('doubleHolder').addEventListener('click', function (e) {
   
           if(e.target.classList.contains('double')){
              var btn = document.createElement('button');
              btn.setAttribute('class', 'double');
              btn.innerHTML = 'double';

              var btn2 = document.createElement('button');
              btn2.setAttribute('class', 'double');
              btn2.innerHTML = 'double';
             
              this.appendChild(btn);
              this.appendChild(btn2);
              this.removeChild(e.target);   
           }
        }); 
    </script>
  </body>
</html>
